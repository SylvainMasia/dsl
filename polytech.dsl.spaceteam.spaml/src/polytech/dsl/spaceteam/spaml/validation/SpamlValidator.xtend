/*
 * generated by Xtext 2.14.0
 */
package polytech.dsl.spaceteam.spaml.validation

import arduinoML.PluggedElement
import org.eclipse.xtext.validation.Check
import java.util.HashSet
import arduinoML.Program
import arduinoML.State
import arduinoML.ArduinoMLPackage
import arduinoML.SensorDigital
import arduinoML.Actuator
import arduinoML.Condition
import arduinoML.Transition
import arduinoML.TemporalCondition

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class SpamlValidator extends AbstractSpamlValidator {
	
	public static val INVALID_PIN = 'invalidPin'

	@Check
	def checkPluggedElementPinValid(PluggedElement pluggedElement) {
		if (pluggedElement instanceof SensorDigital || pluggedElement instanceof Actuator) {
			if (pluggedElement.pin < 0 || pluggedElement.pin > 13) {
				error('Pin should be 0 => pin <= 13', ArduinoMLPackage.Literals.PLUGGED_ELEMENT__PIN, 0);
			}
		} else {
			if (pluggedElement.pin < 14 || pluggedElement.pin > 19) {
				error('Pin should be 14 => pin <= 19', ArduinoMLPackage.Literals.PLUGGED_ELEMENT__PIN, 0);
				// cause A0 = 14 and A5 = 19
			}
		}
		return;
	}
	
	@Check
	def checkPluggedElementPinNotDouble(arduinoML.State state) {
		var isADelayCondition = false;
		for (var i = 0; i < state.transitions.size; i++) {
			val t = state.transitions.get(i);
			for (Condition condition : t.conditions) {
				if (condition instanceof TemporalCondition) {
					if (isADelayCondition == false) {
						isADelayCondition = true;
					} else {
						error('A state can have only one TemporalCondition', ArduinoMLPackage.Literals.STATE__TRANSITIONS, i);
					}
				}
			}
		}
	}
	
	@Check
	def checkPluggedElementPinNotDouble(Program program) {
		val pinsUsedDigital = new HashSet<Integer>();
		val pinName = new HashSet<String>();
		val stateName = new HashSet<String>();
		val pinsUsedAnalog = new HashSet<Integer>();
		for (var i = 0; i < program.pluggedElements.size; i++) {
			val pluggedElement = program.pluggedElements.get(i);
			if (pluggedElement instanceof SensorDigital || pluggedElement instanceof Actuator) {
				if (pinsUsedDigital.contains(pluggedElement.pin)) {
					error('Pin digital ' + pluggedElement.pin + ' is already used', ArduinoMLPackage.Literals.PROGRAM__PLUGGED_ELEMENTS, i)
				} else {
					pinsUsedDigital.add(pluggedElement.pin);
				}
			} else {
				if (pinsUsedAnalog.contains(pluggedElement.pin)) {
					error('Pin analog ' + pluggedElement.pin + ' is already used', ArduinoMLPackage.Literals.PROGRAM__PLUGGED_ELEMENTS,  i)
				} else {
					pinsUsedAnalog.add(pluggedElement.pin);
				}
			}
			
			if (pinName.contains(pluggedElement.name)) {
				error('Pin name ' + pluggedElement.name + ' is already used', ArduinoMLPackage.Literals.PROGRAM__PLUGGED_ELEMENTS, i)
			} else {
				pinName.add(pluggedElement.name);
			}
		}
		
		for (var i = 0; i < program.states.size; i++) {
			val state = program.states.get(i);
			if (stateName.contains(state.name)) {
				error('State name ' + state.name + ' is already used', ArduinoMLPackage.Literals.PROGRAM__STATES, i)
			} else {
				stateName.add(state.name);
			}
		}
	}
	
}
